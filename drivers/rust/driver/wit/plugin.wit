package plugin:jwt;

world plugin {
    import log: func(msg: string);

    enum entry-type {
        // Matcher for contents of messages, requests or response bodies
        CONTENT-MATCHER,
        // Generator for contents of messages, requests or response bodies
        CONTENT-GENERATOR,
        // Transport for a network protocol
        TRANSPORT,
        // Matching rule for content field/values
        MATCHER,
        // Type of interaction
        INTERACTION
    }

    // Entry to be added to the core catalogue. Each entry describes one of the features the plugin provides.
    // Entries will be stored in the catalogue under the key "plugin/$name/$type/$key".
    record catalogue-entry {
      // Entry type
      entry-type: entry-type,
      // Entry key
      key: string,
      // Associated data required for the entry. For CONTENT_MATCHER and CONTENT_GENERATOR types, a "content-types"
      // value (separated by semi-colons) is required for all the content types the plugin supports.
      values: list<tuple<string, string>>
    }

    // Enum of content type override. This is a hint on how the content type should be treated.
    enum content-type-hint {
        // Determine the form of the content using the default rules of the Pact implementation
        DEFAULT,
        // Contents must always be treated as a text form
        TEXT,
        // Contents must always be treated as a binary form
        BINARY
    }

    // a request, response or message body
    record body {
      // The content type of the body in MIME format (i.e. application/json)
      content-type: string,
      // Bytes of the actual content
      content: list<u8>,
      // Content type override to apply (if required). If omitted, the default rules of the Pact implementation
      // will be used
      content-type-hint: option<content-type-hint>
    }

    /*
        // Represents a matching rule
        message MatchingRule {
          // Type of the matching rule
          string type = 1;
          // Associated data for the matching rule
          google.protobuf.Struct values = 2;
        }

        // List of matching rules
        message MatchingRules {
          repeated MatchingRule rule = 1;
        }

        // Example generator
        message Generator {
          // Type of generator
          string type = 1;
          // Associated data for the generator
          google.protobuf.Struct values = 2;
        }*/

    // Plugin configuration added to the pact file by the configure-interaction step
    record plugin-configuration {
      // Data to be persisted against the interaction (as JSON)
      interaction-configuration: string,
      // Data to be persisted in the Pact file metadata (Global data, as JSON)
      pact-configuration: string
    }

    /*
          // All matching rules to apply
          map<string, MatchingRules> rules = 2;
          // Generators to apply
          map<string, Generator> generators = 3;
          // For message interactions, any metadata to be applied
          google.protobuf.Struct messageMetadata = 4;
          // Plugin specific data to be persisted in the pact file
          PluginConfiguration pluginConfiguration = 5;
          // Markdown/HTML formatted text representation of the interaction
          string interactionMarkup = 6;
          // Type of markup used
          enum MarkupType {
            // CommonMark format
            COMMON_MARK = 0;
            // HTML format
            HTML = 1;
          }
          MarkupType interactionMarkupType = 7;
          // All matching rules to apply to any message metadata
          map<string, MatchingRules> metadata_rules = 9;
          // Generators to apply to any message metadata
          map<string, Generator> metadata_generators = 10;
        }
    */
    record interaction-contents {
        // Description of what part this interaction belongs to (in the case of there being more than one, for instance,
        // request/response messages)
        part-name: string,
        // Contents for the interaction
        contents: body,
        // Plugin specific data to be persisted in the pact file
        plugin-configuration: plugin-configuration
    }

    // Details for the interaction to configure
    record interaction-details {
        interaction: list<interaction-contents>,
        plugin-config: option<plugin-configuration>
    }

    // Request to preform a comparison on an actual body given the expected one
    record compare-contents-request {
      // Expected body from the Pact interaction
      expected: body,
      // Actual received body
      actual: body,
      // If unexpected keys or attributes should be allowed. Setting this to false results in additional keys or fields
      // will cause a mismatch
      allow-unexpected-keys: bool,
      // Map of expressions to matching rules. The expressions follow the documented Pact matching rule expressions
      // map<string, MatchingRules> rules = 4;
      // Additional data added to the Pact/Interaction by the plugin
      plugin-configuration: plugin-configuration
    }

    // Indicates that there was a mismatch with the content type and the body was not compared
    record content-type-mismatch {
      // Expected content type (MIME format)
      expected: string,
      // Actual content type received (MIME format)
      actual: string
    }

    // A mismatch for an particular item of content
    record content-mismatch {
      // Expected data bytes
      expected: list<u8>,
      // Actual data bytes
      actual: list<u8>,
      // Description of the mismatch
      mismatch: string,
      // Path to the item that was matched. This is the value as per the documented Pact matching rule expressions.
      path: string,
      // Optional diff of the contents
      diff: option<string>,
      // Part of the interaction that the mismatch is for: body, headers, metadata, etc.
      mismatch-type: string
    }

    // Response to the CompareContentsRequest with the results of the comparison
    record compare-contents-response {
      // There was a mismatch with the types of content. If this is set, the results may not be set.
      type-mismatch: option<content-type-mismatch>,
      // Results of the match, keyed by matching rule expression
      results: list<tuple<string, list<content-mismatch>>>
    }

    // Init function is called after the plugin is loaded. It needs to return the plugin catalog
    // entries to be added to the global catalog
    export init: func(implementation: string, version: string) -> list<catalogue-entry>;

    // Updated catalogue. This will be sent when the core catalogue has been updated (probably by a plugin loading).
    export update-catalogue: func(catalogue: list<catalogue-entry>);

    // Request to configure/setup the interaction for later verification. Data returned will be persisted in the pact file.
    export configure-interaction: func(content-type: string, config-json: string) -> result<interaction-details, string>;

    // Request to perform a comparison of some contents (matching request)
    export compare-contents: func(request: compare-contents-request) -> result<compare-contents-response, string>;
}
